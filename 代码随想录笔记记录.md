代码随想录网站：https://programmercarl.com/

# 算法性能分析

## 时间复杂度分析

O代表的就是一般情况，而不是严格的上界，面试中算法的时间复杂度是多少指的都是一般情况。深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。

O(1)常数阶 < $O(\log n)$对数阶 < $O(n)$线性阶 < $O(n^2)$平方阶 < $O(n^3)$立方阶 < $O(2^n)$指数阶，但是也要注意大常数，如果这个常数非常大，数据规模比较小，高阶的算法时间复杂度可能更低。其中log并不一定是以2为底

## 超时原因

LeetCode程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s。

计算机的运算速度主要看CPU的配置，1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期），称之为为赫兹，1GHz = 10亿Hz，不能认为一个时钟周期就是一次CPU运算。比如：1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。除此之外cpu还要执行各种其他进程任务，所以可以自己做实验看看1s能执行多少次操作

## 递归算法时间复杂度

递归算法的时间复杂度本质上是要看: **递归的次数 \* 每次递归中的操作次数**。如果把递归抽象成树，树的结点个数就是递归次数。一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点。

## 空间复杂度

空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。

# 数组

数组是存放在连续内存空间上的相同类型数据的集合。 数组下标都是从0开始的，内存空间地址连续，**所以在删除或者增添元素的时候，就难免要移动其他元素的地址。** java中二维数组内存地址不连续。

## 二分查找

数组有序+无重复元素可以考虑一下二分法。因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，可以滑动左右区间找到目标值的索引范围。**总之只要是个有序数组（不一定是数组形式）查找某个值都可以考虑一下二分法。**	注意如果涉及乘法的话可能会出现数据类型越界的情况，要么转成更大的类型，要么想办法转化成除法。

二分法中while (left <= right) 经常写乱，主要是因为**对区间的定义没有想清楚**，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

### [left, right]

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

### [left, right)

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

## 移除元素

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

### 暴力解法

两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。

### 双指针法（快慢指针法）

通过一个**快指针和慢指针在一个for循环下完成**两个for循环的工作。  **双指针法（快慢指针法）在数组和链表的操作中是非常常见**的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。

```java
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。其实就是把不相等的元素移到最前面就行了。

class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex, fastIndex=0;
        for(slowIndex=0;fastIndex<nums.length;fastIndex++){
            if(nums[fastIndex]!=val){
                nums[slowIndex]=nums[fastIndex];//这种写法在移除元素的同时还保证剩余元素的相对位置不变
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```

**注意：**双指针一共有四种情况，同时在前向后遍历；同时在后向前遍历；一前一后向中间遍历；同时在中间向两边遍历。做题时需要考虑那种情况最简单，别随便选一个，要对比一下，花不了多长时间。

## 长度最小子数组

### 暴力法

两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是$O(n^2)$。

### 滑动窗口

主要用来求解**无序数组中某个连续子数组**问题，一般对这个子数组的要求有长度最大最小或者总和最大最小等等，

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。也可以理解为双指针法的一种

实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

另外数组是否越界也要考虑

```java
//可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$的暴力解法降为$O(n)$。cpp版
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

若涉及字母数字计数问题，可以自己用数组构建一个哈希表

```java
//这里先引入三个重要的数据区间，ASCII码的十进制表示：
a~z [97~122]
[91~96] 6个字符我们暂时不关心
A~Z [65~90]
1~9 [48~57]
```

# 链表

## 链表的分类

### 单链表

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）链接的入口节点称为链表的头结点也就是head。

### 双链表

每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

### 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

## 链表的储存方式和定义

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

```java
public class ListNode {
    // 结点的值
    int val;
    // 下一个结点
    ListNode next;
    // 节点的构造函数(无参)
    public ListNode() {
    }
    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }
    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

## 链表的操作及性能分析

链表节点的增删只要修改节点之间的指向就行了，时间复杂度$O(1)$，查找的时间复杂度是$O(n)$。这与数组刚好相反。

## 移除链表中元素

### 直接使用原来的链表

在单链表中移除头结点 和 移除其他节点的操作方式是不一样，需要单独写一段逻辑来处理移除头结点的情况。

### 设置一个虚拟头结点

**可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

## 设计链表







# 个人常见问题

## 逻辑问题

1. 写代码时写了多个单if语句的顺序执行，一定要注意if之间的关系，不要想当然认为前一个if进行了，后面就不会进行，或者说直接方法结束，要是这样想必须加上else或者直接return，否则后面语句会执行