代码随想录网站：https://programmercarl.com/

# 算法性能分析

## 时间复杂度分析

O代表的就是一般情况，而不是严格的上界，面试中算法的时间复杂度是多少指的都是一般情况。深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。

O(1)常数阶 < $O(\log n)$对数阶 < $O(n)$线性阶 < $O(n^2)$平方阶 < $O(n^3)$立方阶 < $O(2^n)$指数阶，但是也要注意大常数，如果这个常数非常大，数据规模比较小，高阶的算法时间复杂度可能更低。其中log并不一定是以2为底

## 超时原因

LeetCode程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s。

计算机的运算速度主要看CPU的配置，1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期），称之为为赫兹，1GHz = 10亿Hz，不能认为一个时钟周期就是一次CPU运算。比如：1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。除此之外cpu还要执行各种其他进程任务，所以可以自己做实验看看1s能执行多少次操作

## 递归算法时间复杂度

递归算法的时间复杂度本质上是要看: **递归的次数 \* 每次递归中的操作次数**。如果把递归抽象成树，树的结点个数就是递归次数。一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点。

## 空间复杂度

空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。

# 数组

数组是存放在连续内存空间上的相同类型数据的集合。 数组下标都是从0开始的，内存空间地址连续，**所以在删除或者增添元素的时候，就难免要移动其他元素的地址。** java中二维数组内存地址不连续。

## 二分查找

数组有序+无重复元素可以考虑一下二分法。因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，可以滑动左右区间找到目标值的索引范围。**总之只要是个有序数组（不一定是数组形式）查找某个值都可以考虑一下二分法。**	注意如果涉及乘法的话可能会出现数据类型越界的情况，要么转成更大的类型，要么想办法转化成除法。

二分法中while (left <= right) 经常写乱，主要是因为**对区间的定义没有想清楚**，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

### [left, right]

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

### [left, right)

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

## 移除元素

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

### 暴力解法

两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。

### 双指针法（快慢指针法）

通过一个**快指针和慢指针在一个for循环下完成**两个for循环的工作。  **双指针法（快慢指针法）在数组和链表的操作中是非常常见**的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。

```java
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。其实就是把不相等的元素移到最前面就行了。

class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex, fastIndex=0;
        for(slowIndex=0;fastIndex<nums.length;fastIndex++){
            if(nums[fastIndex]!=val){
                nums[slowIndex]=nums[fastIndex];//这种写法在移除元素的同时还保证剩余元素的相对位置不变
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```

**注意：**双指针一共有四种情况，同时在前向后遍历；同时在后向前遍历；一前一后向中间遍历；同时在中间向两边遍历。做题时需要考虑那种情况最简单，别随便选一个，要对比一下，花不了多长时间。

## 长度最小子数组

### 暴力法

两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是$O(n^2)$。

### 滑动窗口

主要用来求解**无序数组中某个连续子数组**问题，一般对这个子数组的要求有长度最大最小或者总和最大最小等等，

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。也可以理解为双指针法的一种

实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

另外数组是否越界也要考虑

```java
//可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$的暴力解法降为$O(n)$。cpp版
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

若涉及字母数字计数问题，可以自己用数组构建一个哈希表

```java
//这里先引入三个重要的数据区间，ASCII码的十进制表示：
a~z [97~122]
[91~96] 6个字符我们暂时不关心
A~Z [65~90]
1~9 [48~57]
```

# 链表

## 链表的分类

### 单链表

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）链接的入口节点称为链表的头结点也就是head。

### 双链表

每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

### 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

## 链表的储存方式和定义

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

```java
public class ListNode {
    // 结点的值
    int val;
    // 下一个结点
    ListNode next;
    // 节点的构造函数(无参)
    public ListNode() {
    }
    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }
    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

## 链表的操作及性能分析

链表节点的增删只要修改节点之间的指向就行了，时间复杂度$O(1)$，查找的时间复杂度是$O(n)$。这与数组刚好相反。

## 移除链表中元素

### 直接使用原来的链表

在单链表中移除头结点 和 移除其他节点的操作方式是不一样，需要单独写一段逻辑来处理移除头结点的情况。

### 设置一个虚拟头结点

链表的一大问题就是操作当前节点必须要找前一个节点才能操作，这就造成了，头结点的尴尬，因为头结点没有前一个节点了。**可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

## 设计链表

记得定义size链表大小，并初始化。

## 翻转链表

双指针法或者递归

## 两两交换链表中节点

注意链表的操作中经常起别名，牢记一点，只是把某块内存地址换了个名字。eg：head=head.next指的是原本head.next这块地址有了head这个名字，就是说head的指向变了。

```java
// 递归版本
class Solution {
    public ListNode swapPairs(ListNode head) {
        // base case 退出提交
        if(head == null || head.next == null) return head;
        // 获取当前节点的下一个节点
        ListNode next = head.next;
        // 进行递归
        ListNode newNode = swapPairs(next.next);
        // 这里进行交换
        next.next = head;
        head.next = newNode;

        return next;
    }
} 
```

## 删除倒数第N个节点

虚拟头结点 和 双指针法来移除链表倒数第N个节点。

如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。定义fast指针和slow指针，初始值为虚拟头结点，最终返回虚拟头结点的next节点

## 链表相交

链表交点不是数值相等，而是指针相等，所以交点后面的链表完全一致。两种思路：分别计算出两个链表长度，对其后遍历；两链表分别遍历至末尾后交叉遍历。

## 环形链表

- 判断链表是否环

  - 可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。**fast指针一定先进入环中，相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合

- 如果有环，如何找到这个环的入口

  - 数学推演fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

    ```java
    (x + y) * 2 = x + y + n (y + z)
    整理公式之后为如下公式：x = (n - 1) (y + z) + z
    当 n为1的时候，公式就化解为 x = z，这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。
    n如果大于1就是fast指针在环形转n圈之后才遇到 slow指针。
    其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点
    ```

# 哈希表

## 基础理论

### 哈希表

哈希表是根据关键码的值而直接进行访问的数据结构。其实直白来讲其实数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。**一般哈希表都是用来快速判断一个元素是否出现集合里。**

### 哈希函数

一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把其他数据类型映射为哈希表上的索引数字了。为了保证映射出来的索引数值都落在哈希表上，会再次对数值做一个取模的操作。当映射到相同位置时就用到了**哈希碰撞**。

### 哈希碰撞

- 拉链法：发生冲突的元素都被存储在链表中
- 线性探测法：一定要保证tableSize大于dataSize。 需要依靠哈希表中的空位来解决碰撞问题。

### 常见的三种哈希结构

- 数组
- set （集合）
  - 从Set几个常用实现类可以看出，HashSet是哈希表实现的(不稳定)，LinkedHashSet是链表实现的(按存储顺序存取)，TreeSet是红黑树实现的(按排序顺序存取)；通常我们称Set为单列集合。
- map(映射)
  - 同样从Map常用实现类可以看出，HashMap是哈希表实现的(不稳定)，LinkedHashMap是链表实现的(按存储顺序存取)，TreeMap是红黑树实现的(按排列顺序存取)；通常我们称Map为双列集合
  - Map中还有一个特别的实现类Hashtable，这是JDK1.0遗留下来的，现已经被HashMap替代，Hashtable较HashMap的区别与Vector较ArrayList的区别相似：Hashtable是线程安全的，效率低；HashMap是线程不安全的，效率高。

## 有效的字母异位词

涉及字母数字计数问题，可以自己用数组构建一个哈希表，而且比较个数的话别老想着加完之后比较，也可一边加一边减这样不太会产生int越界的问题。

HashMap的key和value不是基本数据类型无法进行用比较运算符，当使用Integer时要注意在128以下是可以用比较运算符的，超过要把Integer转成int才行，用Integer的intValue()方法，或者用.equals()方法。

eg：[字母异位词分组]给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次

```java
//输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
//输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String,List<String>>map=new HashMap<>();
        for(String s:strs){
            char[]temp=s.toCharArray();
            Arrays.sort(temp);
            String t=String.valueOf(temp);
            if(!map.containsKey(t))map.put(String.valueOf(t),new ArrayList<String>());
            map.get(t).add(s);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

## 两个数组的交集

注意：**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**没有限制数值的大小，就无法使用数组来做哈希表了。**而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

使用set集合的话里面的数据类型不是基本数据类型，如果要输出int数组不能直接用set.toArray(T [] a)，这样得到的结果是Integer类型需要再次遍历转换，所以可以直接对set集合进行遍历。

list集合允许重复，set集合自动去重。

```java
int[] resArr = new int[resSet.size()];
int index = 0;
//将结果几何转为数组
for (int i : resSet) {
    resArr[index++] = i;
}
```

## 快乐数

题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

**当遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**



# 个人常见问题

## 逻辑问题

1. 写代码时写了多个单if语句的顺序执行，一定要注意if之间的关系，不要想当然认为前一个if进行了，后面就不会进行，或者说直接方法结束，要是这样想必须加上else或者直接return，否则后面语句会执行