代码随想录网站：https://programmercarl.com/

# 算法性能分析

## 时间复杂度分析

O代表的就是一般情况，而不是严格的上界，面试中算法的时间复杂度是多少指的都是一般情况。深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。

O(1)常数阶 < $O(\log n)$对数阶 < $O(n)$线性阶 < $O(n^2)$平方阶 < $O(n^3)$立方阶 < $O(2^n)$指数阶，但是也要注意大常数，如果这个常数非常大，数据规模比较小，高阶的算法时间复杂度可能更低。其中log并不一定是以2为底

## 超时原因

LeetCode程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s。

计算机的运算速度主要看CPU的配置，1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期），称之为为赫兹，1GHz = 10亿Hz，不能认为一个时钟周期就是一次CPU运算。比如：1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。除此之外cpu还要执行各种其他进程任务，所以可以自己做实验看看1s能执行多少次操作

## 递归算法时间复杂度

递归算法的时间复杂度本质上是要看: **递归的次数 \* 每次递归中的操作次数**。如果把递归抽象成树，树的结点个数就是递归次数。一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点。

## 空间复杂度

空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。

# 数组

数组是存放在连续内存空间上的相同类型数据的集合。 数组下标都是从0开始的，内存空间地址连续，**所以在删除或者增添元素的时候，就难免要移动其他元素的地址。** java中二维数组内存地址不连续。

## 二分查找

数组有序+无重复元素可以考虑一下二分法。因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，可以滑动左右区间找到目标值的索引范围。**总之只要是个有序数组（不一定是数组形式）查找某个值都可以考虑一下二分法。**	注意如果涉及乘法的话可能会出现数据类型越界的情况，要么转成更大的类型，要么想办法转化成除法。

二分法中while (left <= right) 经常写乱，主要是因为**对区间的定义没有想清楚**，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

### [left, right]

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

### [left, right)

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

## 移除元素

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

### 暴力解法

两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。

### 双指针法（快慢指针法）

通过一个**快指针和慢指针在一个for循环下完成**两个for循环的工作。  **双指针法（快慢指针法）在数组和链表的操作中是非常常见**的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。

```java
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。其实就是把不相等的元素移到最前面就行了。

class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex, fastIndex=0;
        for(slowIndex=0;fastIndex<nums.length;fastIndex++){
            if(nums[fastIndex]!=val){
                nums[slowIndex]=nums[fastIndex];//这种写法在移除元素的同时还保证剩余元素的相对位置不变
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```

**注意：**双指针一共有四种情况，同时在前向后遍历；同时在后向前遍历；一前一后向中间遍历；同时在中间向两边遍历。做题时需要考虑那种情况最简单，别随便选一个，要对比一下，花不了多长时间。

## 长度最小子数组

### 暴力法

两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是$O(n^2)$。

### 滑动窗口

主要用来求解**无序数组中某个连续子数组**问题，一般对这个子数组的要求有长度最大最小或者总和最大最小等等，

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。也可以理解为双指针法的一种

实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

另外数组是否越界也要考虑

```java
//可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$的暴力解法降为$O(n)$。cpp版
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

若涉及字母数字计数问题，可以自己用数组构建一个哈希表

```java
//这里先引入三个重要的数据区间，ASCII码的十进制表示：
a~z [97~122]
[91~96] 6个字符我们暂时不关心
A~Z [65~90]
1~9 [48~57]
```