代码随想录网站：https://programmercarl.com/

# 算法性能分析

## 时间复杂度分析

O代表的就是一般情况，而不是严格的上界，面试中算法的时间复杂度是多少指的都是一般情况。深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。

O(1)常数阶 < $O(\log n)$对数阶 < $O(n)$线性阶 < $O(n^2)$平方阶 < $O(n^3)$立方阶 < $O(2^n)$指数阶，但是也要注意大常数，如果这个常数非常大，数据规模比较小，高阶的算法时间复杂度可能更低。其中log并不一定是以2为底

## 超时原因

LeetCode程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s。

计算机的运算速度主要看CPU的配置，1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期），称之为为赫兹，1GHz = 10亿Hz，不能认为一个时钟周期就是一次CPU运算。比如：1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。除此之外cpu还要执行各种其他进程任务，所以可以自己做实验看看1s能执行多少次操作

## 递归算法时间复杂度

递归算法的时间复杂度本质上是要看: **递归的次数 \* 每次递归中的操作次数**。如果把递归抽象成树，树的结点个数就是递归次数。一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点。

## 空间复杂度

空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。

# 数组

数组是存放在连续内存空间上的相同类型数据的集合。 数组下标都是从0开始的，内存空间地址连续，**所以在删除或者增添元素的时候，就难免要移动其他元素的地址。** java中二维数组内存地址不连续。

## 二分查找

数组有序+无重复元素可以考虑一下二分法。因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，可以滑动左右区间找到目标值的索引范围。**总之只要是个有序数组（不一定是数组形式）查找某个值都可以考虑一下二分法。**	注意如果涉及乘法的话可能会出现数据类型越界的情况，要么转成更大的类型，要么想办法转化成除法。

二分法中while (left <= right) 经常写乱，主要是因为**对区间的定义没有想清楚**，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

### [left, right]

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

### [left, right)

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

## 移除元素

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

### 暴力解法

两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。

### 双指针法（快慢指针法）

通过一个**快指针和慢指针在一个for循环下完成**两个for循环的工作。  **双指针法（快慢指针法）在数组和链表的操作中是非常常见**的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。

```java
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。其实就是把不相等的元素移到最前面就行了。

class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex, fastIndex=0;
        for(slowIndex=0;fastIndex<nums.length;fastIndex++){
            if(nums[fastIndex]!=val){
                nums[slowIndex]=nums[fastIndex];//这种写法在移除元素的同时还保证剩余元素的相对位置不变
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```

**注意：**双指针一共有四种情况，同时在前向后遍历；同时在后向前遍历；一前一后向中间遍历；同时在中间向两边遍历。做题时需要考虑那种情况最简单，别随便选一个，要对比一下，花不了多长时间。

## 长度最小子数组

### 暴力法

两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是$O(n^2)$。

### 滑动窗口

主要用来求解**无序数组中某个连续子数组**问题，一般对这个子数组的要求有长度最大最小或者总和最大最小等等，

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。也可以理解为双指针法的一种

实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

另外数组是否越界也要考虑

```java
//可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$的暴力解法降为$O(n)$。cpp版
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

若涉及字母数字计数问题，可以自己用数组构建一个哈希表

```java
//这里先引入三个重要的数据区间，ASCII码的十进制表示：
a~z [97~122]
[91~96] 6个字符我们暂时不关心
A~Z [65~90]
1~9 [48~57]
```

# 链表

## 链表的分类

### 单链表

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）链接的入口节点称为链表的头结点也就是head。

### 双链表

每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

### 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

## 链表的储存方式和定义

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

```java
public class ListNode {
    // 结点的值
    int val;
    // 下一个结点
    ListNode next;
    // 节点的构造函数(无参)
    public ListNode() {
    }
    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }
    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

## 链表的操作及性能分析

链表节点的增删只要修改节点之间的指向就行了，时间复杂度$O(1)$，查找的时间复杂度是$O(n)$。这与数组刚好相反。

## 移除链表中元素

### 直接使用原来的链表

在单链表中移除头结点 和 移除其他节点的操作方式是不一样，需要单独写一段逻辑来处理移除头结点的情况。

### 设置一个虚拟头结点

链表的一大问题就是操作当前节点必须要找前一个节点才能操作，这就造成了，头结点的尴尬，因为头结点没有前一个节点了。**可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

## 设计链表

记得定义size链表大小，并初始化。

## 翻转链表

双指针法或者递归

## 两两交换链表中节点

注意链表的操作中经常起别名，牢记一点，只是把某块内存地址换了个名字。eg：head=head.next指的是原本head.next这块地址有了head这个名字，就是说head的指向变了。

```java
// 递归版本
class Solution {
    public ListNode swapPairs(ListNode head) {
        // base case 退出提交
        if(head == null || head.next == null) return head;
        // 获取当前节点的下一个节点
        ListNode next = head.next;
        // 进行递归
        ListNode newNode = swapPairs(next.next);
        // 这里进行交换
        next.next = head;
        head.next = newNode;

        return next;
    }
} 
```

## 删除倒数第N个节点

虚拟头结点 和 双指针法来移除链表倒数第N个节点。

如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。定义fast指针和slow指针，初始值为虚拟头结点，最终返回虚拟头结点的next节点

## 链表相交

链表交点不是数值相等，而是指针相等，所以交点后面的链表完全一致。两种思路：分别计算出两个链表长度，对其后遍历；两链表分别遍历至末尾后交叉遍历。

## 环形链表

- 判断链表是否环

  - 可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。**fast指针一定先进入环中，相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合

- 如果有环，如何找到这个环的入口

  - 数学推演fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

    ```java
    (x + y) * 2 = x + y + n (y + z)
    整理公式之后为如下公式：x = (n - 1) (y + z) + z
    当 n为1的时候，公式就化解为 x = z，这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。
    n如果大于1就是fast指针在环形转n圈之后才遇到 slow指针。
    其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点
    ```

# 哈希表

## 基础理论

### 哈希表

哈希表是根据关键码的值而直接进行访问的数据结构。其实直白来讲其实数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。**一般哈希表都是用来快速判断一个元素是否出现集合里。**

### 哈希函数

一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把其他数据类型映射为哈希表上的索引数字了。为了保证映射出来的索引数值都落在哈希表上，会再次对数值做一个取模的操作。当映射到相同位置时就用到了**哈希碰撞**。

### 哈希碰撞

- 拉链法：发生冲突的元素都被存储在链表中
- 线性探测法：一定要保证tableSize大于dataSize。 需要依靠哈希表中的空位来解决碰撞问题。

### 常见的三种哈希结构

- 数组
- set （集合）
  - 从Set几个常用实现类可以看出，HashSet是哈希表实现的(不稳定)，LinkedHashSet是链表实现的(按存储顺序存取)，TreeSet是红黑树实现的(按排序顺序存取)；通常我们称Set为单列集合。
- map(映射)
  - 同样从Map常用实现类可以看出，HashMap是哈希表实现的(不稳定)，LinkedHashMap是链表实现的(按存储顺序存取)，TreeMap是红黑树实现的(按排列顺序存取)；通常我们称Map为双列集合
  - Map中还有一个特别的实现类Hashtable，这是JDK1.0遗留下来的，现已经被HashMap替代，Hashtable较HashMap的区别与Vector较ArrayList的区别相似：Hashtable是线程安全的，效率低；HashMap是线程不安全的，效率高。

## 有效的字母异位词

涉及字母数字计数问题，可以自己用数组构建一个哈希表，而且比较个数的话别老想着加完之后比较，也可一边加一边减这样不太会产生int越界的问题。

HashMap的key和value不是基本数据类型无法进行用比较运算符，当使用Integer时要注意在128以下是可以用比较运算符的，超过要把Integer转成int才行，用Integer的intValue()方法，或者用.equals()方法。

eg：[字母异位词分组]给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次

```java
//输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
//输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String,List<String>>map=new HashMap<>();
        for(String s:strs){
            char[]temp=s.toCharArray();
            Arrays.sort(temp);
            String t=String.valueOf(temp);
            if(!map.containsKey(t))map.put(String.valueOf(t),new ArrayList<String>());
            map.get(t).add(s);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

## 两个数组的交集

注意：**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**没有限制数值的大小，就无法使用数组来做哈希表了。**而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

使用set集合的话里面的数据类型不是基本数据类型，如果要输出int数组不能直接用set.toArray(T [] a)，这样得到的结果是Integer类型需要再次遍历转换，所以可以直接对set集合进行遍历。

list集合允许重复，set集合自动去重。

```java
int[] resArr = new int[resSet.size()];
int index = 0;
//将结果几何转为数组
for (int i : resSet) {
    resArr[index++] = i;
}
```

## 快乐数

题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

**当遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**

## 两数之和

暴力的解法是两层for循环查找，时间复杂度是$O(n^2)$。

使用数组和set来做哈希法的局限：

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            int temp=target-nums[i];
            if(map.containsKey(temp))return new int[]{i,map.get(temp)};
            map.put(nums[i],i);//每次判断之后再put而不是直接将map初始化，这样可以避免同一位置元素的干扰
        }
        return new int[0];
    }
}
```

## 四数之和

问题：给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

分析：首先明确一点我要实现的算法一般来说要比暴力法时间复杂度低，比如n平法降到n或者nlogn，这道题暴力法是n的4次方那么降到n平方就算成功，所以自然就想到数组两两组合分别遍历两组数组就降到了n平方。通常暴力法就是多层for循环，怎么把多层拆开就是重点，复杂度自然就降低了。

## 三数之和

对于无序数组要先想一想排序后会不会简单

问题：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

本题难点是如何去重！！！

### 哈希表法

两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。

### 双指针法

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

时间复杂度：$O(n^2)$。

```java
// 错误去重方法，将会漏掉-1,-1,2 这种情况
/*
if (nums[i] == nums[i + 1]) {
    continue;
}
*/
// 正确去重方法
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
//后两个元素去重操作应该放在找到一个三元组之后
res.add(Arrays.asList(nums[i],nums[left],nums[right]));
while(left<right&&nums[left]==nums[left+1])left++;
while(left<right&&nums[right]==nums[right-1])right--;
```

同样的道理四数之和、五数之和、六数之和等等都采用这种解法。只是多了一层、两层、三层循环罢了，双指针法能把原本暴力解法的复杂度降低一阶。

## 总结

在元素数目已知且较少的情况下可以使用数组作为哈希表；仅关心元素是否存在时使用set集合；需要记录每个元素详细信息要使用map。

# 字符串

字符串是若干字符组成的有限序列，也可以理解为是一个字符数组

## 替换空格

问题：请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

### StringBuilder拼接

最容易理解

### 扩容字符数组后使用双指针

首先使用StringBuilder扩充数组到每个空格替换成"%20"之后的大小。然后**从后向前替换空格**，也就是双指针法，过程如下：i指向新长度的末尾，j指向旧长度的末尾。

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

## 翻转字符串中单词

如果**不使用辅助空间，空间复杂度要求为$O(1)$。**只能在原字符串上下功夫，将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。

所以解题思路如下：

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

## 左旋字符串

**不能申请额外空间，只能在本串上操作**情况下

可以通过局部反转+整体反转 达到左旋转的目的。

具体步骤为：

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

## 一个串中查找是否出现过另一个串

这是KMP 经典题目。

### KMP作用

KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

### 前缀表

next数组就是一个前缀表（prefix table）**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

如果暴力匹配，会发现不匹配，此时就要从头匹配了。但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配。

首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

### 最长公共前后缀

**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。**前缀表要求的就是相同前后缀的长度。**

**因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。**

### 前缀表和next数组

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。**这并不涉及到KMP的原理，而是具体实现，next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）**

### 时间复杂度分析

其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是$O(n)$，之前还要单独生成next数组，时间复杂度是$O(m)$。所以整个KMP算法的时间复杂度是$O(n+m)$的。

next数组构建

1. 初始化

   1. 定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。

   2. ```java
      int j = -1;
      next[0] = j;
      //next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）
      //所以初始化next[0] = j 。
      ```

2. 处理前后缀不相同的情况

   1. j初始化为-1，i从1开始遍历，进行s[i] 与 s[j+1]的比较。next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。

      那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。

   2. ```text
      while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
          j = next[j]; // 向前回退
      }
      ```

3. 处理前后缀相同的情况

   1. 如果s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。

   2. ```text
      if (s[i] == s[j + 1]) { // 找到相同的前后缀
          j++;
      }
      next[i] = j;
      ```

```java
//最终next数组函数
public void getNext(int[] next, String s){
    int j = -1;
    next[0] = j;
    for (int i = 1; i<s.length(); i++){
        while(j>=0 && s.charAt(i) != s.charAt(j+1)){
            j=next[j];
        }

        if(s.charAt(i)==s.charAt(j+1)){
            j++;
        }
        next[i] = j;
    }
}
```

### 使用next数组做匹配

在文本串s里 找是否出现过模式串t。

定义两个下标j 指向模式串起始位置，i指向文本串起始位置。

接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。

如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。

```text
while(j >= 0 && s[i] != t[j + 1]) {
    j = next[j];
}
```

如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：

```text
if (s[i] == t[j + 1]) {
    j++; // i的增加在for循环里
}
```

如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了

本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。

```text
if (j == (t.size() - 1) ) {
    return (i - t.size() + 1);
}
```

## 一个字符串是否由重复子字符串构成

**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**

# 栈与队列

## 用栈实现队列

栈Stack是一个类可以直接实例化，其方法：push(E e)、pop()、peek()、empty()。因为其继承了AbstractCollections，所以size和isEmpty方法都有。

使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈**一个输入栈，一个输出栈**，这里要注意输入栈和输出栈的关系。

在push数据的时候，只要数据放进输入栈就好，**但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）**，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。

## 用队列实现栈

单向队列Queue是一个接口，需要使用多态来实例化，其实现类LinkedList，其方法有：offer(E e)、poll()、peek()，因为其继承了AbstractCollections，所以size和isEmpty方法都有。

此外双向队列Deque也是一个接口，需要使用多态来实例化，其实现类LinkedList，也就是offer(E e)、poll()、peek()都分别有First和Last方法。它也可以作为栈来使用，使用双向对列实现栈相比于Stack的时间复杂度更低。

**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。**

## 有效的括号

**括号匹配是使用栈解决的经典问题。**由于栈结构的特殊性，非常适合做对称匹配类的题目。

针对此题首先要弄清楚，字符串里的括号不匹配有几种情况。

1. 字符串里左方向的括号多余了 ，所以不匹配：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false
2. 括号没有多余，但是括号的类型没有匹配上：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false
3. 字符串里右方向的括号多余了，所以不匹配：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

小技巧：在匹配左括号的时候，让对应的右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！

## 删除字符串中的所有相邻重复项

编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，比如fortran。

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

## 逆波兰表达式求值

逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

**栈与递归之间在某种程度上是可以转换的！****其实逆波兰表达式相当于是二叉树中的后序遍历**。 可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList();
        for (int i = 0; i < tokens.length; ++i) {
            if ("+".equals(tokens[i])) {        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等
                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理
            } else if ("-".equals(tokens[i])) {
                stack.push(-stack.pop() + stack.pop());
            } else if ("*".equals(tokens[i])) {
                stack.push(stack.pop() * stack.pop());
            } else if ("/".equals(tokens[i])) {
                int temp1 = stack.pop();
                int temp2 = stack.pop();
                stack.push(temp2 / temp1);
            } else {
                stack.push(Integer.valueOf(tokens[i]));
            }
        }
        return stack.pop();
    }
}
```



### 数据类型的转换

int转String：**s=i+""; s=String.valueOf(i);** 区别在于法一会多产生一个String对象

String转int：**i=Integer.parseInt(s); i=Integer.valueOf(s).intValue();**区别在于法二会多产生一个String对象，都会抛异常

## 滑动窗口最大值

这是使用单调队列的经典题目。

可能会想用一个大顶堆（优先级队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了， **但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。**

**其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。**

那么这个维护元素单调递减的队列就叫做**单调队列，即单调递减或单调递增的队列。需要我们自己来一个单调队列**

**不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。**

首先要明确的是，题解中单调队列里的pop和push接口，仅适用于本题哈。单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。

## 求前 K 个高频元素

1. 要统计元素出现频率
2. 对频率排序
3. 找出前K个高频元素

对频率进行排序，这里可以使用优先级队列。优先级队列**就是一个披着队列外衣的堆**，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。优先级队列内部元素是自动依照元素的权值排列。缺省情况下PriorityQueue利用大顶堆完成对元素的排序，**堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）

本题使用优先级队列来对部分频率进行排序。不用快排的原因是：只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

**要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。**

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int[] result = new int[k];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }

        Set<Map.Entry<Integer, Integer>> entries = map.entrySet();
        // 根据map的value值正序排，相当于一个小顶堆,o1>o2是小顶堆，默认是大顶堆
        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());
        for (Map.Entry<Integer, Integer> entry : entries) {
            queue.offer(entry);
            if (queue.size() > k) {
                queue.poll();
            }
        }
        for (int i = k - 1; i >= 0; i--) {
            result[i] = queue.poll().getKey();
        }
        return result;
    }
}
```







# 个人常见问题

## 逻辑问题

1. 写代码时写了多个单if语句的顺序执行，一定要注意if之间的关系，不要想当然认为前一个if进行了，后面就不会进行，或者说直接方法结束，要是这样想必须加上else或者直接return，否则后面语句会执行